package wftech.worldgenrevisited.virtualpack;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.mojang.datafixers.util.Pair;

import net.minecraft.resources.ResourceLocation;
import wftech.worldgenrevisited.WorldgenRevisited;
import wftech.worldgenrevisited.Config;
import wftech.worldgenrevisited.utils.RegistryUtils;

/*
 * Ah fuck
 */

public class JsonConfigFeatures {
	
	public static List<ResourceLocation> RESOURCES_TO_DELETE = new ArrayList<ResourceLocation>();
	public static List<ResourceLocation> RESOURCES_TO_ADD = new ArrayList<ResourceLocation>();
	public static Set<String> USED_NAMES = new HashSet<String>();

	public static void createAdjustedFeatures() {

		Map<ResourceLocation, Float> locationMultiplierLookupTable = generateResourceMultiplierLookupTable();
		
		List<Pair<ResourceLocation, JsonElement>> jsonsRaw = new ArrayList<Pair<ResourceLocation, JsonElement>>();
		
		//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Trying to load JSONs.");
		
		for(ResourceLocation location: locationMultiplierLookupTable.keySet()) {
			//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Trying to load JSONs -> " + location);
			JsonElement jsonRepresentingFeaturePlacement = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(location);
			if(jsonRepresentingFeaturePlacement != null) {
				jsonsRaw.add(new Pair(location, jsonRepresentingFeaturePlacement));
				//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher AddPackFindersEventWatcher Found entry for " + location);
			} else {
				WorldgenRevisited.LOGGER.error("Failed to find entry for feature " + location + ". Please double-check the name.");
			}
		}
		
		//VirtualPackResources vpResource = new VirtualPackResources(WorldgenRevisited.MOD_ID, false);

		//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Trying to load JSONs 2");
		for(Pair<ResourceLocation, JsonElement> rlocElementPair: jsonsRaw) {
			//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcherTrying to load JSONs ===> " + rlocElementPair);
			JsonElement newCopy = rlocElementPair.getSecond().deepCopy();
			//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Copied!");
			try {
				JsonArray placementArray = newCopy.getAsJsonObject().get("placement").getAsJsonArray();
				
				ResourceLocation originalResourceLocation = rlocElementPair.getFirst();
				float multiplier = locationMultiplierLookupTable.get(originalResourceLocation);
				
				RESOURCES_TO_DELETE.add(originalResourceLocation);
				//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Got resource location " + originalResourceLocation);
				String basePath = "autogenerated_" + originalResourceLocation.getNamespace() + "_" + originalResourceLocation.getPath();
				String newPath = basePath;
				for(int i = 0; i < 100000; i++) {
					if(USED_NAMES.contains(newPath)) {
						newPath = basePath + i;
					} else {
						break;
					}
				}
				
				String longNewPath = "worldgen/placed_feature/" + newPath + ".json";
				ResourceLocation longNewResourceLocation = new ResourceLocation("worldgenrevisited", longNewPath);
				ResourceLocation newResourceLocation = new ResourceLocation("worldgenrevisited", newPath);
				RESOURCES_TO_ADD.add(newResourceLocation);
				/*
				newCopy.getAsJsonObject().remove("feature");
				newCopy.getAsJsonObject().addProperty("feature", newResourceLocation.toString());
				*/
				//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Updated JSON (pre-placement patch) " + newCopy);
				
				boolean editOccurred = attemptUpdatePlacements(placementArray, multiplier);

				//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Sending new JSON -> " + newCopy.toString());
				VirtualPackResources.STREAM_MAP.put(longNewResourceLocation, new MemoryBasedIoSupplier(newCopy.toString(), newResourceLocation.toString()));

				//new MemoryBasedIoSupplier(newCopy.toString(), newResourceLocation.toString());
				//Reader reader = resource.openAsReader()
				
				if(!editOccurred) {

					WorldgenRevisited.LOGGER.error("Failed to find any frequency-related placement options for feature json " + rlocElementPair.getSecond());
					WorldgenRevisited.LOGGER.error("While most features have frequency options, some do not. Likewise, some mods might use "
							+ "their own custom frequency options. Please use /dumpfeature "
							+ "<feature name> (not yet implemented) to produce an editable file under <mod directory>/worldgenrevisited and manually edit the file "
							+ "there. Then, please add this feature to the list of features to remove (optional). WorldgenRevisited will then "
							+ "load your edited feature in place of the original feature. You can add new frequency options to any "
							+ "feature, even if they do not come with placement options by default.");
				
				}
				
				
			} catch (IllegalStateException e){

				WorldgenRevisited.LOGGER.error("IllegalStateException: Unsupported format or malformed datapack feature " 
						+ rlocElementPair.getFirst() + " with json " + rlocElementPair.getSecond());
				WorldgenRevisited.LOGGER.error("If you feel that this error message was caused by an unsupported format, please"
						+ " leave a comment on the WorldgenRevisited modpage so that I can add support in a later update. Use "
						+ "/dumpfeature <featurename> (not yet implemented) to produce a copy of the original for editing purposes. The file will "
						+ "be deposited under <mod directory>/worldgenrevisited. ");
				e.printStackTrace();
				
			}
			
			//vpResource.addResourceLocation(rlocElementPair.getFirst(), newCopy);
		}
	}
	
	public static void handleCountType(JsonObject placementOption, float frequency_amplifier) {
		if(placementOption.has("count")) {
			
			//Complex cases:
			//{"type":"minecraft:count","count":{"type":"minecraft:weighted_list","distribution":[{"weight":95,"data":0},{"weight":5,"data":1}]}}
			//{"type":"minecraft:count","count":{"type":"minecraft:uniform","value":{"max_inclusive":5,"min_inclusive":0}}}

			JsonElement countOption = placementOption.get("count");
			if(countOption.isJsonObject()) {
				JsonObject subJsonObject = placementOption.get("count").getAsJsonObject();
				
				if(subJsonObject.get("type").getAsString().equals("minecraft:weighted_list")) {
					
					JsonArray distributionArray = subJsonObject.getAsJsonArray("distribution");
					for(JsonElement distributionElement: distributionArray) {
						JsonObject distribution = distributionElement.getAsJsonObject();
						int data = distribution.get("data").getAsInt();
						data *= frequency_amplifier;
						distribution.remove("data");
						distribution.addProperty("data", data);
					}
					
				} else if(subJsonObject.get("type").getAsString().equals("minecraft:uniform")) {
					
					JsonObject valueObject = subJsonObject.getAsJsonObject("value");
					int min_inclusive = valueObject.get("min_inclusive").getAsInt();
					int max_inclusive = valueObject.get("max_inclusive").getAsInt();
					
					min_inclusive *= frequency_amplifier;
					max_inclusive *= frequency_amplifier;
					
					valueObject.remove("min_inclusive");
					valueObject.addProperty("min_inclusive", min_inclusive);
					valueObject.remove("max_inclusive");
					valueObject.addProperty("max_inclusive", max_inclusive);
				}
					
			} else {
				//Primitive case
				float countFloat = placementOption.get("count").getAsFloat();
				int count = Math.round(countFloat * frequency_amplifier);
				count = count > 256 ? 256 : count;
				placementOption.remove("count");
				placementOption.addProperty("count", count);
			}
		}
	}
	
	public static void handleRarityFilterType(JsonObject placementOption, float frequency_amplifier) {

		//{"type":"minecraft:rarity_filter","chance":5}
		JsonElement chanceOption = placementOption.get("chance");
		if(chanceOption.isJsonPrimitive()) {
			int chance = Math.round(chanceOption.getAsInt() * (1 / frequency_amplifier));
			chance = chance <= 0 ? 1 : chance;
			placementOption.remove("chance");
			placementOption.addProperty("chance", chance);
		}
	}
	
	public static void handleNoiseThresholdCountType(JsonObject placementOption, float frequency_amplifier) {
		//{"type":"minecraft:noise_threshold_count","noise_level":-0.8,"below_noise":5,"above_noise":10}
		//idk what to do here, the transformation required seems nonlinear. More thinking is required.
		//Maybe I should set up this project so the user is encouraged to declare the desired amplification
		//somewhere, then I analyze what they do to understand how amplification levels tend to correlate
		//with what an altered file should look like?
		//Doing nothing for now.
	}
	
	public static boolean attemptUpdatePlacements(JsonArray placementArray, float multiplier) {
		boolean editOccurred = false;
		for(JsonElement placementOptionRaw: placementArray) {
			JsonObject placementOption = placementOptionRaw.getAsJsonObject();
			
			if(placementOption.has("minecraft:rarity_filter")) {
				handleRarityFilterType(placementOption, multiplier);
				editOccurred = true;
			} else if (placementOption.get("type").getAsString().equals("minecraft:count")) {
				handleCountType(placementOption, multiplier);
				editOccurred = true;
			} else if (placementOption.get("type").getAsString().equals("minecraft:noise_threshold_count")) {
				//{"type":"minecraft:noise_threshold_count","noise_level":-0.8,"below_noise":5,"above_noise":10}
				handleNoiseThresholdCountType(placementOption, multiplier);

				WorldgenRevisited.LOGGER.error("Unsupported placement type \"minecraft:noise_threshold_count\". Please use "
						+ "/dumpfeature <feature name> (not yet implemented) to produce an editable file under <mod directory>/worldgenrevisited and"
						+ "manually edit the file there. Then, please add this feature to the list of features to remove (optional). "
						+ "WorldgenRevisited will then load your edited feature in place of the original feature.");
				editOccurred = true;
			}
		}
		
		return editOccurred;
	}
	
	public static Map<ResourceLocation, Float> generateResourceMultiplierLookupTable(){
		Map<ResourceLocation, Float> lookupTable = new HashMap<ResourceLocation, Float>();
		
		List<String> requestedChangesRaw = Config.CHANGE_ORE_FREQUENCY_LIST.get();

		//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Requested changes -> " + requestedChangesRaw);
		
		for(String requestedChangeRaw: requestedChangesRaw) {
			String[] parts = requestedChangeRaw.split("=");
			String unprocessedResourceLocation = parts[0];
			float multiplier = Float.parseFloat(parts[1]);
			lookupTable.put(new ResourceLocation(unprocessedResourceLocation), multiplier);
		}
		
		return lookupTable;
	}
	
	public static void addRequestedResourcesToDeleteToList(){
		List<String> requestedChangesRaw = Config.REMOVE_FEATURES_LIST.get();

		//WorldgenRevisited.LOGGER.error("[WorldgenRevisited] AddPackFindersEventWatcher Requested **removal** changes -> " + requestedChangesRaw);
		
		for(String requestedChangeRaw: requestedChangesRaw) {
			RESOURCES_TO_DELETE.add(new ResourceLocation(requestedChangeRaw));
		}
	}
	
}
