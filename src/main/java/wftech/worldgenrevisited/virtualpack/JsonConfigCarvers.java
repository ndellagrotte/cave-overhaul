package wftech.worldgenrevisited.virtualpack;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.mojang.datafixers.util.Pair;

import net.minecraft.resources.ResourceLocation;
import wftech.worldgenrevisited.WorldgenRevisited;
import wftech.worldgenrevisited.Config;
import wftech.worldgenrevisited.utils.RegistryUtils;

/*
 * Ah fuck
 */

public class JsonConfigCarvers {
	
	public static List<ResourceLocation> RESOURCES_TO_DELETE = new ArrayList<ResourceLocation>();
	public static List<ResourceLocation> RESOURCES_TO_ADD = new ArrayList<ResourceLocation>();
	public static Set<String> USED_NAMES = new HashSet<String>();
	
	public static void createAdjustedCarvers() {

		//Load the list of resources and generate the resource-multiplier lookup table
		Map<ResourceLocation, Float> locationMultiplierLookupTable = generateResourceMultiplierLookupTable();
		Map<ResourceLocation, Float> locationReplacementLookupTable = generateResourceReplacementLookupTable();

		increaseFrequencies(locationMultiplierLookupTable, false);
		increaseFrequencies(locationReplacementLookupTable, true);
	}
	
	public static void increaseFrequencies(Map<ResourceLocation, Float> locationIncreaseValueLookupTable, boolean isReplacement) {
		
		//Will hold the list of raw, unprocessed JSONs grabbed from our registry
		List<Pair<ResourceLocation, JsonElement>> jsonsRaw = new ArrayList<Pair<ResourceLocation, JsonElement>>();

		//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver lookup: " + locationIncreaseValueLookupTable);
		
		//Load in the unprocessed JSONs
		for(ResourceLocation location: locationIncreaseValueLookupTable.keySet()) {
			//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver looking for JSON with location: " + location);
			JsonElement jsonRepresentingCarverPlacement = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(location);
			//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver RESOURCE_LOCATION_JSON_MAP keylist: ");
			for(ResourceLocation key: RegistryUtils.RESOURCE_LOCATION_JSON_MAP.keySet()) {
				//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver " + key);
			}
			if(jsonRepresentingCarverPlacement != null) {
				jsonsRaw.add(new Pair(location, jsonRepresentingCarverPlacement));
			} else {
				WorldgenRevisited.LOGGER.error("Failed to find entry for carver " + location + ". Please double-check the name.");
			}
		}
		
		//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver found the following to add: " + jsonsRaw);
		
		//Process each JSON and replace relevant entries
		for(Pair<ResourceLocation, JsonElement> rlocElementPair: jsonsRaw) {
			JsonElement newCopy = rlocElementPair.getSecond().deepCopy();
			try {
				
				ResourceLocation originalResourceLocation = rlocElementPair.getFirst();
				float increaseValue = locationIncreaseValueLookupTable.get(originalResourceLocation);
				
				RESOURCES_TO_DELETE.add(originalResourceLocation);
				String basePath = "autogenerated_" + originalResourceLocation.getNamespace() + "_" + originalResourceLocation.getPath();
				String newPath = basePath;
				for(int i = 0; i < 100000; i++) {
					if(USED_NAMES.contains(newPath)) {
						newPath = basePath + i;
					} else {
						break;
					}
				}
				
				String longNewPath = "worldgen/configured_carver/" + newPath + ".json";
				ResourceLocation longNewResourceLocation = new ResourceLocation("worldgenrevisited", longNewPath);
				ResourceLocation newResourceLocation = new ResourceLocation("worldgenrevisited", newPath);
				RESOURCES_TO_ADD.add(newResourceLocation);

				//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver adding RL " + newResourceLocation + " with registration path " + longNewResourceLocation);
				
				JsonObject carverConfig = newCopy.getAsJsonObject().get("config").getAsJsonObject();
				
				if(isReplacement) {
					attemptUpdatePlacementsReplacement(carverConfig, increaseValue);
				} else {
					attemptUpdatePlacementsMultiplier(carverConfig, increaseValue);
				}

				VirtualPackResources.STREAM_MAP_CARVER.put(longNewResourceLocation, new MemoryBasedIoSupplier(newCopy.toString(), newResourceLocation.toString()));				
				
			} catch (IllegalStateException e){

				WorldgenRevisited.LOGGER.error("IllegalStateException: Unsupported format or malformed carver " 
						+ rlocElementPair.getFirst() + " with json " + rlocElementPair.getSecond());
				e.printStackTrace();
			}
		}
		
	}
	
	public static void attemptUpdatePlacementsMultiplier(JsonObject configObject, float multiplier) {
		boolean editOccurred = false;
		
		float probabilityUnadjusted = configObject.get("probability").getAsFloat();
		float probabilityAdjusted = probabilityUnadjusted;
		probabilityAdjusted *= multiplier;
		probabilityAdjusted = probabilityAdjusted > 1.0f ? 1.0f : probabilityAdjusted;

		configObject.remove("probability");
		configObject.addProperty("probability", probabilityAdjusted);
	}
	
	public static void attemptUpdatePlacementsReplacement(JsonObject configObject, float newValue) {
		boolean editOccurred = false;
		float newValueClamped = Math.max(0.0f, Math.min(newValue, 1.0f));

		configObject.remove("probability");
		configObject.addProperty("probability", newValueClamped);
	}
	
	public static List<String> parseRawStringList(String sList){
		String[] parts = sList.replace("[", "").replace("]", "").replace(" ", "").split(",");
		return List.of(parts);
	}
	
	public static Map<ResourceLocation, Float> generateResourceMultiplierLookupTable(){
		Map<ResourceLocation, Float> lookupTable = new HashMap<ResourceLocation, Float>();

		//int world_type = (int) WorldgenRevisited.EARLY_LOAD_CONFIG.get(Config.KEY_WORLDGEN_TYPE);
		//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver Getting list '" + parseRawStringList();
		List<String> requestedChangesRaw = new ArrayList<String>();
		if(WorldgenRevisited.EARLY_LOAD_CONFIG != null) {
			requestedChangesRaw = (List<String>) WorldgenRevisited.EARLY_LOAD_CONFIG.get(Config.KEY_CARVER_MULTIPLIED_FREQUENCY_CHANGE);
		}
		
		//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver found prelim lookup info " + requestedChangesRaw);

		
		for(String requestedChangeRaw: requestedChangesRaw) {
			String[] parts = requestedChangeRaw.split("=");
			String unprocessedResourceLocation = parts[0];
			float multiplier = Float.parseFloat(parts[1]);
			lookupTable.put(new ResourceLocation(unprocessedResourceLocation), multiplier);
		}
		
		return lookupTable;
	}
	
	public static Map<ResourceLocation, Float> generateResourceReplacementLookupTable(){
		Map<ResourceLocation, Float> lookupTable = new HashMap<ResourceLocation, Float>();

		List<String> requestedChangesRaw = new ArrayList<String>();
		if(WorldgenRevisited.EARLY_LOAD_CONFIG != null) {
			requestedChangesRaw = (List<String>) WorldgenRevisited.EARLY_LOAD_CONFIG.get(Config.KEY_CARVER_REPLACED_FREQUENCY_CHANGE);
		}
		
		//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver 2 found prelim lookup info " + requestedChangesRaw);
		
		for(String requestedChangeRaw: requestedChangesRaw) {
			String[] parts = requestedChangeRaw.split("=");
			String unprocessedResourceLocation = parts[0];
			float multiplier = Float.parseFloat(parts[1]);
			lookupTable.put(new ResourceLocation(unprocessedResourceLocation), multiplier);
		}
		
		return lookupTable;
	}

	public static void createWorldtypeCarvers() {
		JsonElement v12Config = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "v12_caves"));
		//WorldgenRevisited.LOGGER.info("[WorldgenRevisited] JsonConfigCarver v12Config -> " + v12Config);
		int world_type = 2;
		if(WorldgenRevisited.EARLY_LOAD_CONFIG != null) {
			world_type = (int) WorldgenRevisited.EARLY_LOAD_CONFIG.get(Config.KEY_WORLDGEN_TYPE);
		}
		
		//-1 = No carvers, not even vanilla. 0 = 1.12 retrogen, 1 = 1.16, 2 = current version vanilla.
		JsonElement canyonConfig = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "canyons"));
		JsonElement canyonLowYConfig = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "canyons_low_y"));
		JsonElement otherVanillaCaveConfig = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "vanilla_cave"));
		
		//remove these if appropriate
		JsonElement mcCanyon = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("minecraft", "canyon"));
		JsonElement mcCaveExtra = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("minecraft", "cave_extra_underground"));
		JsonElement mcCave = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("minecraft", "cave"));
		
		if(world_type == -2) {
			JsonElement v12CaveConfig = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "v12_caves"));

			//RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "vanilla_cave"));
			
			
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "canyons"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "canyons_low_y"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "caves_noise_distribution"));
			
			
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver1"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver2"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver3"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver4"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver5"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver6"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_carver7"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer1_lava1"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer1_lava2"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer2_lava"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer3_lava"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer3_water"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer4_water1"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer4_water2"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer5_water"));
			
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer6_water"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer7_water"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_layer8_water"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_final_stage"));

			//noise_cave_simplex_boring
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "noise_cave_simplex_boring"));
			
			
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "canyons"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave_extra_underground"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave"));
			
			//Removing the final stage carver as it runs out of order- I add it to the RESOURCES_TO_ADD listings
			//because the BiomeModifier will grab it and put it aside, then I delete it since I don't actually want it
			//to apply at the normal stage :)
			RESOURCES_TO_DELETE.add(new ResourceLocation("worldgenrevisited", "noise_underground_rivers_final_stage"));
			
		} else if(world_type == 0) {
			JsonElement v12CaveConfig = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "v12_caves"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "canyons"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "canyons_low_y"));
			//RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "vanilla_cave"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "v12_caves"));

			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "canyons"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave_extra_underground"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave"));
		} else if(world_type == 1) {
			JsonElement v12CaveConfig = RegistryUtils.RESOURCE_LOCATION_JSON_MAP.get(new ResourceLocation("worldgenrevisited", "v16_caves"));

			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "canyons"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "canyons_low_y"));
			//RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "vanilla_cave"));
			RESOURCES_TO_ADD.add(new ResourceLocation("worldgenrevisited", "v16_caves"));

			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "canyons"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave_extra_underground"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave"));
		} else if(world_type == -1) {

			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "canyons"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave_extra_underground"));
			RESOURCES_TO_DELETE.add(new ResourceLocation("minecraft", "cave"));
			
		} else if(world_type == 2) {
			//do  nothing
		}
	}
	
}
